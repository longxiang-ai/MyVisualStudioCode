// import some basic libraries
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>

// make space for the store of the matrix
#define MAX 100
int array[MAX][MAX]; // the array to store the input matrix
int N;               // the exact size of the matrix

// the timer module, with the variable start to record start time and end to record the stop time of one iteration
// and the double variable duration is to sum up the total time
clock_t start, end;
double duration = 0; // initialize duration to be zero

// function : input the data from console, this is used for test
void ReadFromConsole()
{
    // the realizition of this part is just a simple double loop
    for (int i = 0; i < N; i++)
    {
        for (int j = 0; j < N; j++)
        {
            scanf("%d", &array[i][j]);
        }
    }
}

// function : input the data from the file, where the name is like "randomxxx.txt",xxx means the number of N
// the random files are generated by Python program in advance.
// parameter : int block, we make each "random" file 100 lines, each line contains n*n integers ranges from -100 to 100
// the the "block" can help us to get the block-th line , then read the block-th matrix into "array"
void ReadFromFile(int block)
{
    char a[] = "random";
    char b[] = ".txt";
    char num[4] = {'\0'};
    char filename[15] = {'\0'};
    itoa(N, num, 10); // transit N from an integer to char array and store it in num
    strcat(filename, a);
    strcat(filename, num);
    strcat(filename, b);
    // printf("%s\n", filename);
    // strcat 函数将文件名拼接成random+xxx+.txt的文件格式，然后进行文件读取
    // get the file pointer, and the model is read-only
    FILE *fp = fopen(filename, "r");
    int count = 0;                                       // count is a counter to skip the previous blocks
    int temp = 0;                                        // temp is to store the gotten character, if it's \n, that means one block passed
    while (count < block && ((temp = fgetc(fp)) != EOF)) // 跳过指定的块数，随机数生成的文件保证一行中存储的刚好是一个矩阵
    {
        if (temp == '\n')
        {
            count++;
        }
    }
    // After we skip the previous blocks, we can read the content in a simple double loop
    for (int i = 0; i < N; i++)
    {
        for (int j = 0; j < N; j++)
        {
            fscanf(fp, "%d", &array[i][j]);
        }
    }
}

// function : this algorithm calculates all the possible submatrices of the given N*N matrix, then store the maximum and return
// return value : int, which is the maximum of the maximum of all the submatrices
// Time complexity : obviously O(N^6)
int EverySubmatrix()
{
    // This can be realized as a simple 6-layer loop, each time when the local sum is larger than the max, replace the max sum.
    int sum = 0;
    for (int i = 0; i < N; i++)
    {
        for (int j = 0; j < N; j++)
        {
            for (int m = i; m < N; m++)
            {
                for (int n = j; n < N; n++)
                {
                    int thissum = 0; // when calculating the sum in i <= x <= m, j <= y <= n, we need to initialize the local sum to be zero
                    for (int ii = i; ii <= m; ii++)
                    {
                        for (int jj = j; jj <= n; jj++)
                        {
                            thissum += array[ii][jj]; // calculate the local sum
                        }
                    }
                    if (thissum > sum)
                    {
                        sum = thissum; // compare the local sum and global sum, if larger, replace
                    }
                }
            }
        }
    }
    return sum;
}

// function : this algorithm 
// return value : int, which is the maximum of the maximum of all the submatrices
// Time complexity : O(N^4)
int MaxSubMatrix()
{
    int maxsum = 0;
    for (int i = 0; i < N; i++)
    {
        for (int j = 0; j < N; j++)
        {
            int thissum[N];                      // 表示包括当前列，包括当前行-1的和为thissum[j] 其中array[i][j]
            memset(thissum, 0, sizeof(thissum)); // 清零
            int sumrow = 0;                      // 当前所在行的累加和
            for (int m = i; m < N; m++)
            {
                for (int n = j; n < N; n++)
                {
                    sumrow += array[m][n];
                    // sumrow 表示 y = j, i <= x <= m 中所有元素的和
                    thissum[n] += sumrow; 
                    // 在加之前 thissum[n] 表示i <= x <= m  j <= y <= n-1 中的所有元素array[x][y]的和 
                    // 加完之后 表示i <= x <= m  j <= y <= n 中的所有元素array[x][y]的和
                    if (thissum[n] > maxsum)
                    {
                        maxsum = thissum[n];
                    }
                }
                sumrow = 0; // 清零所在行的和
            }
        }
    }
    return maxsum;
}

int MSM()
{
    // 考虑到其一维问题其实可以看成一个1*N的矩阵，所以尝试将N*N的情况进行降维解决
    // 假设需要解决的问题是1*K矩阵的最大子矩阵和，则这个问题退化至MSS
    // 假设需要解决的问题是2*K矩阵的最大子矩阵和，则可以考虑第一行的最大子列和，第二行的最大子列和以及将这两行相加后的最大子列和，这三个解中最大的情况必然是2*K的最大子矩阵和
    // 假设问题的规模为3*K，则结果必然为max{每一行的MSS，每两行和的MSS，以及3行和的MSS}
    // 以此类推，则最终问题演化为计算矩阵第x行至第y行间和并对和矩阵求MSS，最终结果maxsum = max_{x,y} MSS(x,y) 其中MSS(x,y) 表示对第x至第y行的矩阵作和的1*N矩阵的最大子列和,x,y为任意满足 0<=x<=y<=N-1 的整数

    // 为求出从第x行到第y行的任意行的和矩阵，我们可以对array[x][y]做以下改造：
    // 构造a[x][y]，其满足a[x+1][y] = array[x+1][y] + a[x][y] ; a[0][y] = array[0][y]
    // 这样得到的a[x][y] = sum_{i=0,x} array[i][y]
    // 而欲得到第x行到第y行元素按列求和的和矩阵 temp[j] = a[y][j] - a[x-1][j]
    // 然后我们对temp[N] 进行一次MSS即可
    int a[N][N];
    // 第0行为原来的值
    for (int i = 0; i < N; i++)
    {
        a[0][i] = array[0][i];
    }
    // 第i行为原先的第i行加上a[i-1][j]，这一求和过程的复杂度为O(N^2)
    for (int i = 1; i < N; i++)
    {
        for (int j = 0; j < N; j++)
        {
            a[i][j] = a[i - 1][j] + array[i][j];
        }
    }

    int maxsum = 0;
    // 遍历所有 x,y 满足 0<=x<=y<=N-1 的整数
    for (int i = 0; i < N; i++)
    {
        for (int j = i; j < N; j++)
        {
            int temp[N];
            for (int k = 0; k < N; k++)
            {
                if (i == 0)
                {
                    temp[k] = a[i][k];
                }
                else
                {
                    temp[k] = a[j][k] - a[i - 1][k];
                }
            }
            int thissum = MaxSubSequence(temp, N); // O(N)
            if (thissum > maxsum)
            {
                maxsum = thissum;
            }
        }
    }
    return maxsum;
}
// 仿照教材中的O(N)算法解决最小子列和问题
int MaxSubSequence(int *a, int n) // O(N)
{
    int sum = 0;
    int thissum = 0;
    for (int i = 0; i < n; i++)
    {
        thissum += a[i];
        if (thissum > sum)
        {
            sum = thissum;
        }
        if (thissum < 0)
        {
            thissum = 0;
        }
    }
    return sum;
}
void main()
{
    N = 100;
    // scanf("%d", &N);
    // Read();
    for (int i = 0; i < 10; i++)
    {
        ReadFromFile(i);
        start = clock();
        int result = 0;
        result = EverySubmatrix();
        printf("%d\n", result);
        // result = MaxSubMatrix();
        // printf("%d\n", result);
        // result = MSM();
        // printf("%d\n", result);
        end = clock();
        duration += ((double)(end - start)) / CLK_TCK;
    }
    printf("duration = %lf\n", duration);
}
